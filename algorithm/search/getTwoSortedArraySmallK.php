<?php
/**
 * 找出两个有序数组中第K个数
 * 之前我谈到，对于一个有序数组来说，找到第K个数是非常简单的，假如我们有两个有序的数组，希望从中找到第K小的数呢？
 * 这个问题最直观的解决方法就是像归并排序中的归并算法那样，从头开始比较，找到那第K小的数，那么平均时间复杂度就是O(m+n)，其中m，n分别是两个数组的长度。
 * 不过通过二分查找法，得到一个复杂度为O(log(m+n))的算法（很多地方说这个算法的复杂度是O(log m + log n)，我没有进行准确的演算和统计，但是个人认为O(log(m+n))才对）。先来看算法代码，然后来分析（或者你也可以看这篇文章）。
 * 这里对于参数的假设如下：数组的索引是以0为基数并且m+n > 0；k是以1为基数并且1<=k <= m+n，两个数组的集合没有重复元素。在这样的假设下，暗示我们总是可以找到那个第k个数。
 *
 * 个人认为这里面最繁琐的是数组索引因为不同的基数而引起的转换问题。比如里面的i和j，很显然i+j == k-1。而实际上，数组A中0-i的元素加上数组B中0-j的元素一共有(i+1)+(j+1) == k+1个数。
 * 因为数组A和B都是有序的，所以我们知道A[i] > A[0…i-1]都大，B[j] > B[0…j-1]。
 * 进一步，如果B[j-1] < A[i] < B[j]，那么A[j]就正好大于 A中前i个数B中的前j个数也就是总共k-1个数，于是A[j]就是我们要找的目标数；
 * 反之如果A[i-1] < B [j] < A[i]，那么B[j]就成立我们要找的数。
 * 万一A[i]和B[j]都不是我们要找的数，要么A[i]比B[j-1]小，要么B[j]比A[i-1]小。
 * 假如是A[i]比B[j-1]小，那么我们可以分析推测出来，A[0…i]都太小而不能成为我们要找的目标，而B[j…n-1]又太大，也不可能是我们要找的目标。所以我们就可以开始二分查找的第二步操作——剪枝，让我们的范围缩小。而因为我们去除了A中较小的部分，所以我们要查找的数也从第k个变成了第(k-i-1)个。
 * 对于B[j]比A[i-1]小的情况也是一样的。
 *
 * 从递归调用的地方，我们看出k总是在不断减小的，简单分析更可以知道，如果k是1的话就会停止递归。（这也是为什么我会认为总的时间复杂度是O(log(m+n))的地方。）所以位于i和j的值选取就变得比较关键。
 * 一开始，我设定 int i = k > m? m-1: k-1;也就是让i相对比较大。虽然平均效率上差不多，但是如果剪枝时总是去除B的前段的话，k减小的速度就比较慢。例如最坏的情况：A中所有的数比B中都要大，而我们正好要找第n个数（也就是B中最后一个数），于是每次递归k都只减小了1。此时的复杂度就成了O(n)。
 * 按数组大小来分配i和j可以做到对于任意的案例k的减少都是比较平均的。
 * 对于那些边界检查，在之前的假设之下其实只是会有相等的情况出现，不过检查区域并不会比检查点糟糕。
 * 进一步，其实剪枝时的(0 < j && A[i] < B[j-1]) 并不需要去检查 0 < j，因为j为0的情况只可能出现在n为0 （即B是一个空数组）。而此时，A[i]已是我们要找的目标而被返回了。写上(0 < j && A[i] < B[j-1]) 只是暗示它其实是((j <= 0 || B[j-1] < A[i])的取反。
 */

function getTwoSortedArraySmallK($a, $b, $k)
{
    $m = count($a);
    $n = count($b);
    return f($a, $m, $b, $n, $k);
}

function f($a, $m, $b, $n, $k)
{
    if ($m > $n) {
        return f($b, $n, $a, $m, $k);
    }
    if ($m == 0) {
        return $b[$k - 1];
    }
    if ($k == 1) {
        return min($a[$k - 1], $b[$k - 1]);
    }
    $pa = floor(min($k / 2, $m));
    $pb = $k - $pa;
    if ($a[$pa - 1] < $b[$pb - 1]) {
        return f(array_slice($a, $pa, $m - $pa), $m - $pa, $b, $n, $k - $pa);
    } else if ($a[$pa - 1] > $b[$pb - 1]) {
        return f($a, $m, array_slice($b, $pb, $n - $pb), $n - $pb, $k - $pb);
    } else {
        return $a[$pa - 1];
    }
}

$a=[1,2,3,4,5,6,9,14,25];
$b=[3,5,6,19,21,24];

echo findMedianSortedArrays($a, $b, 4);
